# -*- coding: utf-8 -*-
"""DeLorean.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g8Rf5UT6jX4IPy-VhnDM58tB6rbyz8K6
"""

## Metrics

# A = Observation
# B = Prediction

from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error, mean_squared_error
import numpy as np

class Metrics:
      
      def __init__(self, observation, prediction):

          self.observation = observation
          self.prediction = prediction

      def MAE(self):

        mae = mean_absolute_error(self.observation,self.prediction)

        return mae

      def MAE_perc(self):

        mae_perc = mean_absolute_percentage_error(self.observation,self.prediction)

        return mae_perc*100

      def MSE(self):

        mse = mean_squared_error(self.observation,self.prediction)

        return mse

      def RMSE(self):

        rmse = mean_squared_error(self.observation,self.prediction ,squared=False)

        return rmse

      def Bias(self):

        bias = np.mean(self.observation-self.prediction )

        return float(bias)

import scipy.stats
from sklearn.linear_model import LinearRegression
from scipy.optimize import curve_fit
from scipy import asarray as ar,exp
import pandas as pd
import matplotlib.pyplot as plt
import math

class DeLorean:

    def __init__(self, features, elevations, observation, prediction, power_curve= None):

        self.features = features # Features to be compared being in a tuple, for example features = ('WS','Wind_speed') or ('Power','Wind Speed') being the sources (observation , prediction)
        self.elevations = elevations  # Elevations to be compared being in a tuple, for example features = ('100m','100 meters') or ('high' , 'lower') being the sources (observation , prediction)
        self.power_curve = power_curve
        self.observation = observation # Dataframe containing the observated values
        self.prediction = prediction # Dataframe containing the predicted values

    def all_metrics(self):

        metrics_list = ['Bias','MAE','MAE_perc','MSE','RMSE']
        self.metrics(metrics_list)
      
        return

    def metrics(self, metrics_list):

        observation , prediction = self.crop_nan()
        observation , prediction = self.crop_zero(observation , prediction)
        met_results = {}
        met = Metrics(observation[self.elevations[0],self.features[0]], prediction[self.elevations[1],self.features[1]])
        for i in range(0,len(metrics_list)):

            if metrics_list[i] == 'Bias':
              bias = met.Bias()
              met_results['Bias'] = bias

            if metrics_list[i]  == 'MAE':
              mae = met.MAE()
              met_results['MAE'] = mae

            if metrics_list[i]  == 'MAE_perc':
              mae_perc = met.MAE_perc()
              met_results['MAE (%)'] = mae_perc

            if metrics_list[i]  == 'MSE':
              mse = met.MSE()
              met_results['MSE'] = mse

            if metrics_list[i]  == 'RMSE':
              rmse = met.RMSE()
              met_results['RMSE'] = rmse

        for i in met_results:
            print(i,': ', met_results[i])

        return 

    def correlate(self):
        
        observation , prediction = self.crop_nan()

        observation , prediction = self.crop_zero(observation , prediction)


        pred= pd.DataFrame({(self.elevations[1],self.features[1]) : prediction[self.elevations[1],self.features[1]]})
        obs =pd.DataFrame({(self.elevations[0],self.features[0]) : observation[self.elevations[0],self.features[0]]})

        X=pred
        y=obs

        reg = LinearRegression().fit(X,y)
        linear =reg.predict(y)
        
        plt.scatter(prediction[self.elevations[1],self.features[1]],observation[self.elevations[0],self.features[0]])
        plt.plot(observation[self.elevations[0],self.features[0]],linear)
        plt.xlabel(self.features[1])
        plt.ylabel(self.features[0])
        plt.grid()
        plt.show()
        print(' ')
        print('R^2 score: ',reg.score(X, y))

        return

    def plot_data(self):

        fig, axs = plt.subplots(3, 1,figsize=(30,15))
        fig.autofmt_xdate()
        
        
        axs[0].plot(self.observation[self.elevations[0],self.features[0]])
        axs[0].set_title('Observation: '+ self.features[0])
        axs[0].set(xlabel='Date', ylabel=self.features[0])
        axs[0].grid(True)
        axs[0].axes.get_xaxis().set_ticks([])
        axs[0].fmt_xdata = mdates.DateFormatter('%Y-%m-%d')

        axs[1].plot(self.prediction[self.elevations[1],self.features[1]])
        axs[1].set_title('Prediction: '+ self.features[1])
        axs[1].set(xlabel='Date', ylabel=self.features[1])
        axs[1].grid(True)
        axs[1].axes.get_xaxis().set_ticks([])
        axs[1].fmt_xdata = mdates.DateFormatter('%Y-%m-%d')


        axs[2].plot(self.observation[self.elevations[0],self.features[0]])
        axs[2].plot(self.prediction[self.elevations[1],self.features[1]])
        axs[2].set_title('Observation & Prediction')
        axs[2].set(xlabel='Date', ylabel=self.features[0]+' & '+ self.features[1])     
        axs[2].grid(True)
        axs[2].axes.get_xaxis().set_ticks([])
        axs[2].fmt_xdata = mdates.DateFormatter('%Y-%m-%d')

        plt.show()

        return
    
    def plot_error(self):
        Error=self.get_error()

        fig, axs = plt.subplots(1, 1,figsize=(30,7))
        axs.plot(Error)
        axs.get_xaxis().set_ticks([])
        plt.show()
        return

    def pair_dfs(self, freq = '15min'):

        start_date = max([self.observation.head(1).index, self.prediction.head(1).index])
        end_date = min([self.observation.tail(1).index, self.prediction.tail(1).index])

        new_prediction = self.prediction.loc[start_date[0]:end_date[0]]
        new_observation = self.observation.loc[start_date[0]:end_date[0]]

        date_line = pd.date_range(start_date[0], end_date[0] , freq=freq)
    
        date_frame = pd.DataFrame({'Date': date_line,'Dates': date_line})
        date_frame.set_index('Date',inplace=True)

        new_prediction = pd.concat([new_prediction, date_frame], axis=1, ignore_index=False, sort=False)
        new_observation = pd.concat([new_observation, date_frame], axis=1, ignore_index=False, sort=False)

        new_prediction = new_prediction.loc[date_frame.index.values]
        new_observation = new_observation.loc[date_frame.index.values]

        new_prediction = new_prediction.drop(columns=['Dates'])
        new_observation = new_observation.drop(columns=['Dates'])

        return new_observation, new_prediction

    def crop_nan(self):

        obs_nan = self.observation[self.elevations[0],self.features[0]].isnull()
        pred_nan = self.prediction[self.elevations[1],self.features[1]].isnull()
        tot_nan=obs_nan.values+pred_nan.values

        new_observation=self.observation.loc[np.invert(tot_nan), :]
        new_prediction=self.prediction.loc[np.invert(tot_nan), :]    

        return new_observation, new_prediction

    def crop_zero(self, observation , prediction):

        obs_nan = observation[self.elevations[0],self.features[0]]==0
        pred_nan = prediction[self.elevations[1],self.features[1]]==0
        tot_nan=obs_nan.values+pred_nan.values

        new_observation=observation.loc[np.invert(tot_nan), :]
        new_prediction=prediction.loc[np.invert(tot_nan), :]    

        return new_observation, new_prediction
    
    def print_impurities():
        return

    def get_error(self):

        observation , prediction = self.crop_nan()
        Error = observation[self.elevations[0],self.features[0]]-prediction[self.elevations[1],self.features[1]]
        return Error

    def error_distribution():

        return

    def fit_distribution(self):

        fig, axs = plt.subplots(1, 3,figsize=(25,5))

        y_obs, x_obs ,_= axs[2].hist(self.observation[self.elevations[0],self.features[0]], bins=20)
        y_pred, x_pred ,_ =axs[2].hist(self.prediction[self.elevations[1],self.features[1]], bins=20)
        axs[2].set_title('Distribution')
        axs[2].set(xlabel=self.features[0]+'/'+self.features[1], ylabel='pdf')
        axs[2].grid(True)     

        axs[0].hist(self.observation[self.elevations[0],self.features[0]], bins=20,density=True)
        axs[1].hist(self.prediction[self.elevations[1],self.features[1]], bins=20,density=True)

        def get_x_points(x):
            a=np.array(range(len(x)-1))
            for i in range(0,len(a)):
                a[i]=(x[i]+x[i+1])/2
            return a

        x_obs=  get_x_points(x_obs)
        x_pred=  get_x_points(x_pred)

        mu =sum(x_pred*y_pred)/(sum(y_pred))
        sigma =math.sqrt(sum(y_pred*(x_pred-mu)**2)/(sum(y_pred)))
        axs[1].plot(x_pred, (1/(sigma * np.sqrt(2 * np.pi)) *np.exp( - (x_pred - mu)**2 / (2 * sigma**2) )),linewidth=2, color='r')
        axs[1].set_title('Prediction: '+ self.features[1])
        axs[1].set(xlabel=self.features[1], ylabel='pdf')
        axs[1].grid(True)     
        
        mu =sum(x_obs*y_obs)/(sum(y_obs))
        sigma =math.sqrt(sum(y_obs*(x_obs-mu)**2)/(sum(y_obs)))
        axs[0].plot(x_obs, (1/(sigma * np.sqrt(2 * np.pi)) *np.exp( - (x_obs - mu)**2 / (2 * sigma**2) )),linewidth=2, color='r')
        axs[0].set_title('Observation: '+ self.features[0])
        axs[0].set(xlabel=self.features[0], ylabel='pdf')
        axs[0].grid(True)     

        plt.show()

        return


    def derivated_power():
        return
